<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="UTF-8" />
  <meta http-equiv="X-UA-Compatible" content="IE=edge" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Document</title>
</head>

<body>
  <!-- 沙箱：防止应用加载的时候 对widow造成污染 -->
  <!-- a应用，更改了window属性  -->
  <!-- b应用，先删掉a应用的属性，再更改b应用的window属性 -->
  <!-- 先保留a应用的属性，失活的时候把修改的属性存起来，激活的时候还原回来 -->
  <!-- 这就是快照，浪费内存，因为要给window拍照 -->

  <script>
    // 多个实例来实现
    class ProxySandbox {
      constructor() {
        this.running = false
        // 使用 Proxy 对 fakeWindow 进行代理
        const fakeWindow = Object.create(null)
        this.proxy = new Proxy(fakeWindow, {
          get: (target, key) => {
            return key in target ? target[key] : window[key]
          },
          set: (target, key, value) => {
            if (this.running) {
              target[key] = value // 将修改操作应用到 fakeWindow 上，而不是真实的 window 对象
            }
            return true
          },
        })
      }
      active() {
        if (!this.running) this.running = true
      }
      inactive() {
        this.running = false
      }
    }
    let sandbox1 = new ProxySandbox()
    let sandbox2 = new ProxySandbox()
    sandbox1.active()
    sandbox2.active()
    sandbox1.proxy.a = 100
    sandbox2.proxy.a = 100
    console.log(sandbox1.proxy.a, sandbox2.proxy.a)
    sandbox1.inactive()
    sandbox2.inactive()
    sandbox1.proxy.a = 200
    sandbox2.proxy.a = 200
    console.log(sandbox1.proxy.a, window.a)
    console.log(sandbox2.proxy.a, window.a)

    // 如何使用的？
    // (function (window) {
    //   window.a = 100
    // })(sandbox1.proxy)

    // (function (window) {
    //   window.a = 100
    // })(sandbox2.proxy)
  </script>
</body>

</html>